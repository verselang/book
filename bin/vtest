#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { spawn, spawnSync } = require('child_process');


// Available Verse VMs, we search the $PATH first. If the executable cannot be
// found then we default to Jan's path.
const testScriptVM = findExecutable("VerseTestScriptCmdVM.exe",
                                    "/mnt/c/fortniteMain/Engine/Restricted/NotForLicensees/Binaries/Win64/VerseTestScriptCmdVM.exe"
                                   );
const clrVM = findExecutable("VerseCLRVM-Win64-Shipping.exe",
                             "/mnt/c/fortniteMain/Engine/Restricted/NotForLicensees/Binaries/Win64/VerseCLRVM-Win64-Shipping.exe"
                            );

const wslPath = findExecutable("wslpath", "/usr/bin/wslpath");

function findExecutable(executable, default_exe) {
  // Use `which` on Unix or `where` on Windows
  const command = process.platform === 'win32' ? 'where' : 'which';
  const result = spawnSync(command, [executable], { encoding: 'utf8' });

  if (result.status === 0 && result.stdout.trim()) {
    const pth = result.stdout.split('\n')[0].trim();
    try {
      // Check if it's actually executable
      fs.accessSync(pth, fs.constants.X_OK);
      return path.resolve(pth);
    } catch {
      return default_exe;
    }
  }
  return default_exe;
}

function printUsage() {
  console.log('Usage: vtest <file-or-directory> [--verbose|--raw]');
  console.log('');
  console.log('Runs Verse tests on a file or all .verse/.versetest files in a directory.');
  console.log('Automatically selects VM based on file extension:');
  console.log('  .verse      -> CLR VM');
  console.log('  .versetest  -> TestScript VM');
  console.log('');
  console.log('Options:');
  console.log('  --verbose   Show detailed error messages for failures');
  console.log('  --raw       Show complete VM output for failures');
  console.log('');
  console.log('Examples:');
  console.log('  vtest verse/08_failure');
  console.log('  vtest verse/08_failure/04.versetest');
  console.log('  vtest verse/08_failure --verbose');
  console.log('  vtest verse/08_failure/04.versetest --raw');
  process.exit(1);
}

function parseArgs() {
  const args = process.argv.slice(2);
  if (args.length < 1) printUsage();

  let target = null;
  let verbose = false;
  let raw = false;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--verbose' || arg === '-v') {
      verbose = true;
    } else if (arg === '--raw' || arg === '-r') {
      raw = true;
    } else if (arg === '--help' || arg === '-h') {
      printUsage();
    } else if (!arg.startsWith('-') && !target) {
      target = arg;
    }
  }

  if (!target) printUsage();

  return { target, verbose, raw };
}

function findVerseFiles(dir) {
  let results = [];

  try {
    const items = fs.readdirSync(dir);

    items.forEach(item => {
      // Skip hidden files
      if (item.startsWith('.')) {
        return;
      }

      const fullPath = path.join(dir, item);

      try {
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          results = results.concat(findVerseFiles(fullPath));
        } else if (stat.isFile() && (item.endsWith('.verse') || item.endsWith('.versetest'))) {
          results.push(fullPath);
        }
      } catch (err) {
        // Skip files that can't be accessed
      }
    });
  } catch (err) {
    // Directory doesn't exist or can't be read
  }

  return results;
}

function parseErrorMessages(output) {
  const lines = output.split('\n');
  const errors = [];
  let i = 0;

  // Skip first line (vproject opened message)
  if (lines.length > 0 && lines[0].includes('vproject has opened')) {
    i = 1;
  }

  // Process lines until we hit the final error messages
  while (i < lines.length) {
    const line = lines[i];
    // Stop if we hit the final error/command lines
    if (line.startsWith('ERROR:') || line.startsWith('Command:')) {
      break;
    }

    // Check if this is a "Build Failure:" line (CLR VM format)
    if (line.startsWith('Build Failure:')) {
      // Make filename optional by adding ? after (.+?)
      const re = /^Build Failure:\s+(.+?)?\((\d+),\s*(\d+),\s*(\d+),\s*(\d+)\):\s*([^\r\n]+)/;
      const m = re.exec(line);
      if (m) {
        const [_, file, lineNumber, startCol, endLine, endCol, message] = m;
        errors.push({ lineNumber, message });
      }
    }
    // Check if this is a "LogVerseBuild: Error:" line (TestScript VM format)
    else if (line.startsWith('LogVerseBuild: Error:')) {
      const re = /^LogVerseBuild: Error:\s+(.+?)\((\d+),(\d+),\s*(\d+),(\d+)\):\s*(.+)/;
      const m = re.exec(line);
      if (m) {
        const [_, file, lineNumber, startCol, endLine, endCol, message] = m;
        errors.push({ lineNumber, message });
      }
    }
    // Check if this is a runtime error (CLR VM format): "-------: <message> :-------"
    else if (line.startsWith('-------:')) {
      const re = /^-------:\s*(.+?)\s*:-------/;
      const m = re.exec(line);
      if (m) {
        const message = m[1];
        errors.push({ lineNumber: 'N/A', message });
      }
    }
    i++;
  }

  return errors;
}

function isSuccess(output) {
  return !output.includes('Build Failure:') && !output.includes('LogVerseBuild: Error:');
}

function runTest(filePath) {
  return new Promise((resolve) => {
    const isTest = filePath.endsWith('.versetest');
      // Both VMs require absolute windows paths when running under WSL.
      // VerseTestScriptCmdVM will silently do nothing and succeed with a Linux path.
      // VerseCLRVM will fail with "Error getting text contents" with a Linux path.
      // This call to wslpath converts a linux path to a windows path.
    const canonicalPath = fs.realpathSync(filePath);

    let targetPath = canonicalPath;
    let tempFile = null;

    // For .verse files, prepend Main():void={} prologue
    if (!isTest) {
      const originalContent = fs.readFileSync(canonicalPath, 'utf8');
      const contentWithPrologue = 'Main():void={}\n' + originalContent;

      // Create temp file with prologue
      const tempDir = path.dirname(canonicalPath);
      tempFile = path.join(tempDir, `.vtest_tmp_${path.basename(canonicalPath)}`);
      fs.writeFileSync(tempFile, contentWithPrologue, 'utf8');
      targetPath = tempFile;
    }

    const windowsPath = spawnSync(wslPath, ['-w', targetPath], {encoding: 'utf8'}).stdout.trim();
    const compilerPath = isTest ? testScriptVM : clrVM;
    const args = compilerPath === testScriptVM ? [windowsPath] : ['--open=' + windowsPath];

    const compiler = spawn(compilerPath, args, { stdio: ['pipe', 'pipe', 'pipe'] });

    let stdout = '';
    let stderr = '';

    compiler.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    compiler.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    compiler.on('close', (code) => {
      // Clean up temp file if created
      if (tempFile && fs.existsSync(tempFile)) {
        try {
          fs.unlinkSync(tempFile);
        } catch (err) {
          // Ignore cleanup errors
        }
      }

      const output = stdout + stderr;
      const success = isSuccess(output) && code === 0;
      const errors = success ? [] : parseErrorMessages(output);

      resolve({
        filePath,
        success,
        errors,
        output
      });
    });

    compiler.on('error', (err) => {
      // Clean up temp file if created
      if (tempFile && fs.existsSync(tempFile)) {
        try {
          fs.unlinkSync(tempFile);
        } catch (cleanupErr) {
          // Ignore cleanup errors
        }
      }

      resolve({
        filePath,
        success: false,
        errors: [{ lineNumber: 'N/A', message: `Failed to run compiler: ${err.message}` }],
        output: ''
      });
    });
  });
}

async function main() {
  const { target, verbose, raw } = parseArgs();

  // Check if target exists
  if (!fs.existsSync(target)) {
    console.error(`Error: '${target}' not found`);
    process.exit(1);
  }

  // Determine if target is a file or directory
  const stat = fs.statSync(target);
  let files = [];

  if (stat.isDirectory()) {
    files = findVerseFiles(target);
    if (files.length === 0) {
      console.log(`No .verse or .versetest files found in '${target}'`);
      return;
    }
    console.log(`Running tests on ${files.length} file(s) in '${target}'...\n`);
  } else if (stat.isFile()) {
    if (!target.endsWith('.verse') && !target.endsWith('.versetest')) {
      console.error(`Error: File must have .verse or .versetest extension`);
      process.exit(1);
    }
    files = [target];
  } else {
    console.error(`Error: '${target}' is not a file or directory`);
    process.exit(1);
  }

  // Group files by directory
  const filesByDir = new Map();
  for (const file of files) {
    const dir = path.dirname(file);
    if (!filesByDir.has(dir)) {
      filesByDir.set(dir, []);
    }
    filesByDir.get(dir).push(file);
  }

  // Run tests, printing directory name before each group
  const results = [];
  for (const [dir, dirFiles] of filesByDir) {
    const dirName = path.basename(dir);
    console.log(`\nTesting ${dirName}/`);

    for (const file of dirFiles) {
      const result = await runTest(file);
      results.push(result);

      const basename = path.basename(file);
      if (result.success) {
        console.log(`  ✓ ${basename}`);
      } else {
        console.log(`  ✗ ${basename}`);
        if (raw) {
          console.log('\n--- Raw Output ---');
          console.log(result.output);
          console.log('--- End Output ---\n');
        } else if (verbose && result.errors.length > 0) {
          result.errors.forEach(err => {
            console.log(`    Line ${err.lineNumber}: ${err.message}`);
          });
        }
      }
    }
  }

  // Summary
  const successes = results.filter(r => r.success);
  const failures = results.filter(r => !r.success);

  console.log('\n' + '='.repeat(50));
  console.log('Summary');
  console.log('='.repeat(50));
  console.log(`Total:     ${results.length}`);
  console.log(`Successes: ${successes.length}`);
  console.log(`Failures:  ${failures.length}`);

  if (failures.length > 0 && !verbose && !raw) {
    console.log('\nFailed files:');
    failures.forEach(f => {
      console.log(`  - ${path.basename(f.filePath)}`);
    });
    console.log('\nRun with --verbose to see error details or --raw to see complete output');
  }

  // Exit with error code if there were failures
  if (failures.length > 0) {
    process.exit(1);
  }
}

main().catch(err => {
  console.error('Unexpected error:', err);
  process.exit(1);
});
